import remapping from '@ampproject/remapping'
import MagicString, { Bundle } from 'magic-string'
import { SourceMapConsumer, SourceMapGenerator, type RawSourceMap } from 'source-map-js'
import { compile } from '..'
import type { DecodedSourceMap } from './source-map'

async function run(rawCss: string, candidates: string[] = []) {
  let source = new MagicString(rawCss)

  let bundle = new Bundle()

  bundle.addSource({
    filename: 'source.css',
    content: source,
  })

  let originalMap = bundle.generateMap({
    hires: 'boundary',
    file: 'source.css.map',
    includeContent: true,
  })

  let compiler = await compile(source.toString(), { from: 'input.css' })

  let css = compiler.build(candidates)
  let decoded = compiler.buildSourceMap()
  let rawMap = toRawSourceMap(decoded)

  let combined = remapping([rawMap, originalMap.toString()], () => null)
  let map = JSON.parse(combined.toString()) as RawSourceMap

  let sources = combined.sources
  let annotations = formattedMappings(map)

  return { css, map, sources, annotations }
}

function toRawSourceMap(map: DecodedSourceMap): string {
  let generator = new SourceMapGenerator()

  for (let mapping of map.mappings) {
    generator.addMapping({
      generated: { line: mapping.generatedLine, column: mapping.generatedColumn },
      original: { line: mapping.originalLine, column: mapping.originalColumn },
      source: mapping.originalSource?.content ?? '',
      name: mapping.name ?? undefined,
    })
  }

  return generator.toString()
}

/**
 * An string annotation that represents a source map
 *
 * It's not meant to be exhaustive just enough to
 * verify that the source map is working and that
 * lines are mapped back to the original source
 *
 * Including when using @apply with multiple classes
 */
function formattedMappings(map: RawSourceMap) {
  const smc = new SourceMapConsumer(map)
  const annotations: Record<
    number,
    {
      original: { start: [number, number]; end: [number, number] }
      generated: { start: [number, number]; end: [number, number] }
    }
  > = {}

  smc.eachMapping((mapping) => {
    let annotation = (annotations[mapping.generatedLine] = annotations[mapping.generatedLine] || {
      ...mapping,

      original: {
        start: [mapping.originalLine, mapping.originalColumn],
        end: [mapping.originalLine, mapping.originalColumn],
      },

      generated: {
        start: [mapping.generatedLine, mapping.generatedColumn],
        end: [mapping.generatedLine, mapping.generatedColumn],
      },
    })

    annotation.generated.end[0] = mapping.generatedLine
    annotation.generated.end[1] = mapping.generatedColumn

    annotation.original.end[0] = mapping.originalLine
    annotation.original.end[1] = mapping.originalColumn
  })

  return Object.values(annotations).map((annotation) => {
    return `${formatRange(annotation.generated)} <- ${formatRange(annotation.original)}`
  })
}

function formatRange(range: { start: [number, number]; end: [number, number] }) {
  if (range.start[0] === range.end[0]) {
    // This range is on the same line
    // and the columns are the same
    if (range.start[1] === range.end[1]) {
      return `${range.start[0]}:${range.start[1]}`
    }

    // This range is on the same line
    // but the columns are different
    return `${range.start[0]}:${range.start[1]}-${range.end[1]}`
  }

  // This range spans multiple lines
  return `${range.start[0]}:${range.start[1]}-${range.end[0]}:${range.end[1]}`
}

// TODO: Test full pipeline through compile(â€¦)
// TODO: Test candidate generation
// TODO: Test utilities generated by plugins

// IDEA: @theme needs to have source locations preserved for its nodes
//
// Example:
// ```css`
// @theme {
//  --color-primary: #333;
// }
// ````
//
//
// When outputting the CSS:
// ```css
// :root {
//  --color-primary: #333;
//  ^^^^^^^^^^^^^^^
//  (should poinr to the property name inside `@theme`)
//                   ^^^^
//                  (should point to the value inside `@theme`)
// }
//
// A deletion like `--color-*: initial;` should obviously destroy this
// information since it's no longer present in the output CSS.
//
// Later declarations of the same key take precedence, so the source
// location should point to the last declaration of the key.
//
// This could be in a separate file so we need to make sure that individual
// nodes can be annotated with file metadata.

// test('source locations are tracked during parsing and serializing', async () => {
//   let ast = CSS.parse(`.foo { color: red; }`, true)
//   toCss(ast, true)

//   if (ast[0].kind !== 'rule') throw new Error('Expected a rule')

//   let rule = annotate(ast[0])
//   expect(rule).toMatchInlineSnapshot(`
//     {
//       "node": [
//         "1:1-1:5",
//         "3:1-3:1",
//       ],
//     }
//   `)

//   let decl = annotate(ast[0].nodes[0])
//   expect(decl).toMatchInlineSnapshot(`
//     {
//       "node": [
//         "1:8-1:18",
//         "2:3-2:13",
//       ],
//     }
//   `)
// })

// test('utilities have source maps pointing to the utilities node', async () => {
//   let { sources, annotations } = run(`@tailwind utilities;`, [
//     //
//     'underline',
//   ])

//   // All CSS generated by Tailwind CSS should be annotated with source maps
//   // And always be able to point to the original source file
//   expect(sources).toEqual(['source.css'])
//   expect(sources.length).toBe(1)

//   expect(annotations).toEqual([
//     //
//     '1:1-11 <- 1:1-20',
//     '2:3-34 <- 1:1-20',
//   ])
// })

// test('@apply generates source maps', async () => {
//   let { sources, annotations } = run(`.foo {
//   color: blue;
//   @apply text-[#000] hover:text-[#f00];
//   @apply underline;
//   color: red;
// }`)

//   // All CSS generated by Tailwind CSS should be annotated with source maps
//   // And always be able to point to the original source file
//   expect(sources).toEqual(['source.css'])
//   expect(sources.length).toBe(1)

//   expect(annotations).toEqual([
//     '1:1-5 <- 1:1-5',
//     '2:3-14 <- 2:3-14',
//     '3:3-14 <- 3:3-39',
//     '4:3-10 <- 3:3-39',
//     '5:5-16 <- 3:3-39',
//     '7:3-34 <- 4:3-19',
//     '8:3-13 <- 5:3-13',
//   ])
// })

// test('license comments preserve source locations', async () => {
//   let { sources, annotations } = run(`/*! some comment */`)

//   // All CSS generated by Tailwind CSS should be annotated with source maps
//   // And always be able to point to the original source file
//   expect(sources).toEqual(['source.css'])
//   expect(sources.length).toBe(1)

//   expect(annotations).toEqual(['1:1-19 <- 1:1-19'])
// })

// test('license comments with new lines preserve source locations', async () => {
//   let { sources, annotations, css } = run(`/*! some \n comment */`)

//   // All CSS generated by Tailwind CSS should be annotated with source maps
//   // And always be able to point to the original source file
//   expect(sources).toEqual(['source.css'])
//   expect(sources.length).toBe(1)

//   expect(annotations).toEqual(['1:1 <- 1:1', '2:11 <- 2:11'])
// })
